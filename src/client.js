import chalk from 'chalk';
import { driverFactory, opcClientDriver } from './drivers/driverFactory';
import {
  // singleRainbow,
  rainbowFlow,
  // coloursToChannels,
  coloursToAllChannels
} from './drivers/middleware';
import { msNow } from './util';
import { colourRateLogger } from './util/graphics';
import { RPI_SPIDEVS, DRV_CONF_DEFAULTS } from '.';
import net from 'net';

// TODO: read this from a JSON file

/**
 * A mapping of serverID to server metadata
 */
const serverConfigs = {
  1: {
    host: 'raspberrypi.local',
    opc_port: 42069,
    channels: RPI_SPIDEVS
  }
};

const clientsConfig = {
  frameRateCap: 40
};

const middleware = [
  // singleRainbow,
  rainbowFlow,
  coloursToAllChannels,
  colourRateLogger
];

// TODO: refactor using limiter https://www.npmjs.com/package/limiter
// Alternatively, accept an idle() function which can ask the controller what its' queue status is like

/**
 * Recursively schedules a function so that it is called at most rateCap times per second
 * @param {function} thing
 * @param {number} rateCap
 */
const scheduleThingRecursive = (thing, rateCap) => {
  const maxTimeMs = 1000.0 / rateCap;
  return () => {
    const startTimeMs = msNow();
    thing();
    const deltaTimeMs = msNow() - startTimeMs;
    setTimeout(scheduleThingRecursive(thing, rateCap), Math.max(0, maxTimeMs - deltaTimeMs));
  };
};

const startClients = async serverConfigs => {
  const clients = await Promise.all(
    Object.entries(serverConfigs).map(([serverID, serverConfig]) => {
      return new Promise((resolve, reject) => {
        const { host, opc_port } = serverConfig;

        const client = new net.Socket();

        serverConfig.client = client;

        client.on('data', data => {
          console.error(chalk`{cyan 游니 ${serverID} recieved} ${data.toString('hex')}`);
          client.destroy(); // kill client after server's response
        });

        client.on('close', () => {
          console.error(chalk`{cyan 游니 ${serverID} closed}`);
        });

        client.on('error', err => {
          console.error(chalk`{cyan 游니 ${serverID} error} {white ${err}}`);
          reject(err);
        });

        client.connect(
          opc_port,
          host,
          () => {
            console.log(chalk`{cyan 游니${serverID} connected} on port: {white ${opc_port}}`);
            resolve(serverConfig);
          }
        );
      });
    })
  );

  // TODO: FrameCallbacks can be split 2 separate async functions:
  //  - read video data -> middleware
  //  - send OPC
  // use async.compose to compose these

  /**
   * an Array of async callbacks for each client which send the OPC data for a single frame
   * generated by middleware to the server.
   */
  const clientFrameCallbacks = clients.map(({ client, channels }) => {
    // Create an operating context for each client frame generator callback
    const context = { ...DRV_CONF_DEFAULTS, channels, client };
    const clientFrameCallback = driverFactory(context, middleware, opcClientDriver);
    // TODO: use async.asyncify here instead
    return clientFrameCallback;
  });

  // Awaits a complete frame to be generated and sent to all servers
  const clientsFrameCallback = async () => {
    return await Promise.all(
      clientFrameCallbacks.map(clientFrameCallback => {
        return new Promise(resolve => {
          resolve(clientFrameCallback());
        });
      })
    );
  };

  setTimeout(scheduleThingRecursive(clientsFrameCallback, clientsConfig.frameRateCap), 1000);
};

startClients(serverConfigs);
